/*
 * Created on 06.04.2005
 * 
 * Copyright 2005 Thorsten Meinl
 * 
 * This file is part of ParMol.
 * ParMol is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * ParMol is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ParMol; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */
package de.parmol;

import de.parmol.util.FrequentFragment;
import de.parmol.util.FragmentSet;
import de.parmol.graph.*;
import java.util.*;


/**
 * This class gathers statistical information during the search like pruned extensions, duplicate fragments and the
 * maximum heap size.
 * 
 * @author Thorsten Meinl <Thorsten.Meinl@informatik.uni-erlangen.de>
 *  
 */
public class Statistics {
	/**
	 * Counts the number of extensions pruned by structural pruning.
	 */
	public int structuralPrunedExtensions = 0;

	/**
	 * Counts the number of extensions pruned by equivalent sibling pruning.
	 */
	public int equivalentSiblingPrunedExtensions = 0;

	/**
	 * Counts the number of non-closed fragments that have already been filtered during the search and not afterwards.
	 */
	public int earlyFilteredNonClosedFragments = 0;

	/**
	 * Counts the number of extensions pruned by perfect extension pruning.
	 */
	public int perfectExtensionPrunedExtensions = 0;

	/**
	 * Counts the number of generated duplicates.
	 */
	public int duplicateFragments = 0;


	/**
	 * Counts the number of non-existing matrices that were generated by FFSM.
	 */
	public int nonExistingPrunedMatrices = 0;
	
	/**
	 * Counts the number of completly overlapping embeddings that have been removed. 
	 */
	public int uncountedSymmetricEmbeddings = 0;
	
	/**
	 * Records the maximum heap size.
	 */
	public int maximumHeapSize = -1;


	/**
	 * checks something
	 * @param fragments
	 */
	public void doAndPrintFragmentCheckForFFSMTeam(FragmentSet fragments) {
		Map nodes = new HashMap();
		Map edges = new HashMap();
		int maxn = 0, maxe = 0;
		for (Iterator it = fragments.iterator(); it.hasNext();) {
			FrequentFragment ack = (FrequentFragment) it.next();
			Graph g = ack.getFragment();
			Integer nc = new Integer(g.getNodeCount());
			Integer n = (Integer) nodes.get(nc);
			if (n == null)
				nodes.put(nc, new Integer(1));
			else
				nodes.put(nc, new Integer(n.intValue() + 1));
			if (g.getNodeCount() > maxn) maxn = g.getNodeCount();

			Integer ec = new Integer(g.getEdgeCount());
			Integer e = (Integer) edges.get(ec);
			if (e == null)
				edges.put(ec, new Integer(1));
			else
				edges.put(ec, new Integer(e.intValue() + 1));
			if (g.getEdgeCount() > maxe) maxe = g.getEdgeCount();
		}
		System.out.println("# of\tNodes\tEdges\t");
		for (int i = 0; i <= maxn || i <= maxe; i++) {
			Integer a = new Integer(i);
			Integer n = (Integer) nodes.get(a);
			if (n == null) n = new Integer(0);
			Integer e = (Integer) edges.get(a);
			if (e == null) e = new Integer(0);
			System.out.println(i + "\t" + n + "\t" + e);
		}
	}


	/**
	 * Prints the gathered statistics on stdout.
	 * 
	 * @param miner the miner that has been used
	 */
	public void printStatistics(AbstractMiner miner) {
		if (miner instanceof de.parmol.FFSM.Miner) {
			System.out.println("Structural pruned extension: " + structuralPrunedExtensions);
			System.out.println("Equivalent sibling pruned extensions: " + equivalentSiblingPrunedExtensions);
			System.out.println("Uncounted completely overlapping embeddings: " + uncountedSymmetricEmbeddings);
			System.out.println("Non-Perfect pruned extensions: " + perfectExtensionPrunedExtensions);
		} else if (miner instanceof de.parmol.FFSM.Miner) {
			System.out.println("Non-existing pruned matrices: " + nonExistingPrunedMatrices);
		}

		System.out.println("Early filtered non-closed fragments: " + earlyFilteredNonClosedFragments);
		System.out.println("Duplicate fragments: " + duplicateFragments);

		if (maximumHeapSize >= 0) {
			System.out.println("Maximum heap size: " + maximumHeapSize + "kB");
		}
	}
}